This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Running development server:

Use node v22.17.0

```
npm run dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

The app home page is `app/page.js`

##

```
1. Test dataset has 100 collections numbered 1 to 100. Each collection has 10 bids, each bid belongs to 1 user (user1 to user10). I use JSON file to serve the test data. The data is generated by: node bin/generateData.js which is  stored in: data/*.json.
2. Endpoint to fetch the data uses Nextjs Api (src/pages/api/*.ts).
   - List of collections: GET /api/collections
   - List of bids, params: collection_id: http://localhost:3005/api/bids?collection_id=10
   - Create collection: POST /api/collections
   - Update collection name, description, stock, price: PUT /api/collections
   - Delete collection: DELETE /api/collections
   - create/update/delete bid: POST/PUT/DELETE /api/bids
   - accept bid (should reject other bids), params: collection_id, bid_id: POST /api/bids/accept
3. list of collections, with
   - if collection owner
     - an button to "edit" / "delete" the collection
   - list of bids under each collection
     - if collection owner: accept bid button
     - if not collection owner and bid is pending: "edit" and "cancel" button
     - add bid button always there and always works even if you have accepted a bid

How would you monitor the application to ensure it is running smoothly?
- Track response times, error rates, throughput, CPU/memory usage.
- Set alerts for spikes in errors or latency.
- Capture frontend and backend exceptions
- Get detailed stack traces, user session data, and breadcrumbs for faster debugging
- Google Analytics to understand user growth.
- Load Testing as a baseline comparison.
Can be done with these stack: Prometheus, Grafana, Sentry, Cloudwatch, ELK.


How would you address scalability and performance?
- Optimize DB using: index, connection pool, read replicas, caching, pagination for long lists of items.
- Stateless API
- Implement rater limit, DOS protections
- Optimize client application, use lazy load components
- Compress assets
- Use CDN for assets

Trade-offs/need to do:
- Sloppy CSS/classnames, with more time can have more organized CSS classes.
- Inconsistent button disabled/show, with more time can make them consistent experience.
- I am using janky native prompt and confirm dialog, which is very fast to implement/use, at the price of looking ugly.
- After a bid is accepted for a collection, you still can create bid for that collection. With more time and resource, more sanity validation is needed for this. A collection need a status to make sure it can accept one bid only once.
- All operation does not restrict limit on the item counts, there should be limit on everything.
- Refactor the page.js into different components/file for easier reading of the code.
- Remove/clean up .css/assets static files generated from application bootstrap 
```